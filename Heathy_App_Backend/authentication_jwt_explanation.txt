🔐 LOGIC ĐĂNG KÝ, ĐĂNG NHẬP VÀ JWT - GIẢI THÍCH CHI TIẾT
================================================================

🎯 TỔNG QUAN LUỒNG AUTHENTICATION
================================

📱 Client App
    ↓ HTTP Request
🌐 AuthController (API Endpoint)
    ↓ Business Logic  
🏭 AuthService (Xử lý logic)
    ↓ Database Operations
🗄️ UserRepository (Lưu/lấy dữ liệu)
    ↓ JWT Operations
🔐 JwtUtils (Tạo/kiểm tra token)
    ↓ Response
📱 Client App (Nhận token)

1. 🆕 LOGIC ĐĂNG KÝ (SIGNUP)
===========================

Bước 1: Client gửi request đăng ký
----------------------------------
POST /api/auth/signup
Content-Type: application/json

{
    "email": "user@example.com",
    "password": "123456",
    "fullName": "Nguyễn Văn A"
}

Bước 2: AuthController nhận request
-----------------------------------
@PostMapping("/signup")
public ResponseEntity<MessageResponse> registerUser(@Valid @RequestBody SignupRequest signUpRequest) {
    // @Valid: Kiểm tra validation (email format, password length...)
    MessageResponse response = authService.registerUser(signUpRequest);
    
    if (response.getMessage().startsWith("Error:")) {
        return ResponseEntity.badRequest().body(response);  // HTTP 400
    }
    return ResponseEntity.ok(response);  // HTTP 200
}

Bước 3: AuthService xử lý logic đăng ký
-------------------------------------
public MessageResponse registerUser(SignupRequest signUpRequest) {
    // 1. Kiểm tra email đã tồn tại chưa
    if (userRepository.existsByEmail(signUpRequest.getEmail())) {
        return new MessageResponse("Error: Email is already in use!");
    }
    
    // 2. Tạo User mới
    User user = new User();
    user.setEmail(signUpRequest.getEmail());
    user.setPasswordHash(passwordEncoder.encode(signUpRequest.getPassword())); // Mã hóa password
    user.setFullName(signUpRequest.getFullName());
    user.setProvider("local"); // Đánh dấu đăng ký local (không phải OAuth)
    
    // 3. Lưu User vào database
    userRepository.save(user);
    
    // 4. Tự động tạo UserProfile và MenstrualCycle cho user mới
    createDefaultUserProfile(user);
    
    return new MessageResponse("User registered successfully!");
}

Bước 4: Tạo dữ liệu mặc định
----------------------------
private void createDefaultUserProfile(User user) {
    // Tạo UserProfile trống (user sẽ cập nhật sau)
    UserProfile profile = new UserProfile();
    profile.setUserId(user.getId());
    profile.setUser(user);
    userProfileRepository.save(profile);
    
    // Tạo MenstrualCycle trống (user sẽ cập nhật sau)
    MenstrualCycle defaultCycle = new MenstrualCycle();
    defaultCycle.setUser(user);
    defaultCycle.setStartDate(null); // Sẽ được set khi user cập nhật
    defaultCycle.setEndDate(null);
    menstrualCycleRepository.save(defaultCycle);
}

2. 🔑 LOGIC ĐĂNG NHẬP (SIGNIN)
=============================

Bước 1: Client gửi request đăng nhập
-----------------------------------
POST /api/auth/signin
Content-Type: application/json

{
    "email": "user@example.com",
    "password": "123456"
}

Bước 2: AuthController nhận request
----------------------------------
@PostMapping("/signin")
public ResponseEntity<AuthResponse> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
    AuthResponse authResponse = authService.authenticateUser(loginRequest);
    return ResponseEntity.ok(authResponse);
}

Bước 3: AuthService xử lý đăng nhập
----------------------------------
public AuthResponse authenticateUser(LoginRequest loginRequest) {
    // 1. Spring Security xác thực email/password
    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(loginRequest.getEmail(), loginRequest.getPassword())
    );
    
    // 2. Lưu authentication vào SecurityContext
    SecurityContextHolder.getContext().setAuthentication(authentication);
    
    // 3. Tạo JWT token
    String jwt = jwtUtils.generateJwtToken(authentication);
    
    // 4. Lấy thông tin user từ authentication
    UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
    
    // 5. Trả về response với token và thông tin user
    return new AuthResponse(jwt,
            userDetails.getId(),
            userDetails.getUsername(),
            userDetails.getFullName());
}

3. 🎫 JWT TOKEN - CHI TIẾT
=========================

Cấu hình JWT
------------
# application.properties
app.jwtSecret=AbCdEfGhIjKlMnOpQrStUvWxYz1234567890...
app.jwtExpirationMs=86400000  # 24 giờ = 24 * 60 * 60 * 1000 ms

Tạo JWT Token
-------------
public String generateJwtToken(Authentication authentication) {
    UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();
    
    return Jwts.builder()
            .setSubject(userPrincipal.getUsername())  // Email của user
            .setIssuedAt(new Date())                  // Thời gian tạo
            .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))  // Thời gian hết hạn
            .signWith(key(), SignatureAlgorithm.HS256)  // Ký bằng secret key
            .compact();
}

Cấu trúc JWT Token
-----------------
Header: {"alg": "HS256", "typ": "JWT"}
Payload: {"sub": "user@example.com", "iat": 1234567890, "exp": 1234654290}
Signature: HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

4. 🛡️ JWT VALIDATION - KIỂM TRA TOKEN
====================================

AuthTokenFilter - Kiểm tra mọi request
-------------------------------------
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) {
    try {
        // 1. Lấy JWT token từ header "Authorization: Bearer <token>"
        String jwt = parseJwt(request);
        
        if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
            // 2. Lấy email từ token
            String email = jwtUtils.getUserNameFromJwtToken(jwt);
            
            // 3. Load user details từ database
            UserDetails userDetails = userDetailsService.loadUserByUsername(email);
            
            // 4. Tạo authentication object
            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
            
            // 5. Lưu vào SecurityContext (đánh dấu user đã đăng nhập)
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
    } catch (Exception e) {
        logger.error("Cannot set user authentication: {}", e.getMessage());
    }
    
    // 6. Tiếp tục xử lý request
    filterChain.doFilter(request, response);
}

Lấy token từ request
-------------------
private String parseJwt(HttpServletRequest request) {
    String headerAuth = request.getHeader("Authorization");
    
    if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
        return headerAuth.substring(7);  // Bỏ "Bearer " đi, chỉ lấy token
    }
    
    return null;
}

Validate JWT Token
-----------------
public boolean validateJwtToken(String authToken) {
    try {
        Jwts.parserBuilder().setSigningKey(key()).build().parse(authToken);
        return true;
    } catch (MalformedJwtException e) {
        logger.error("Invalid JWT token: {}", e.getMessage());
    } catch (ExpiredJwtException e) {
        logger.error("JWT token is expired: {}", e.getMessage());
    } catch (UnsupportedJwtException e) {
        logger.error("JWT token is unsupported: {}", e.getMessage());
    } catch (IllegalArgumentException e) {
        logger.error("JWT claims string is empty: {}", e.getMessage());
    }
    return false;
}

5. 🔐 CẤU HÌNH BẢO MẬT
=====================

WebSecurityConfig - Cấu hình Spring Security
---------------------------------------------
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.cors(withDefaults())  // Cho phép CORS
        .csrf(csrf -> csrf.disable())  // Tắt CSRF (vì dùng JWT)
        .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))  // Stateless
        .authorizeHttpRequests(auth ->
            auth.requestMatchers("/api/auth/**").permitAll()  // Cho phép truy cập auth endpoints
                .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()  // Cho phép OPTIONS requests
                .anyRequest().authenticated()  // Các endpoint khác cần authentication
        );
    
    // Thêm JWT filter
    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
    return http.build();
}

PasswordEncoder - Mã hóa mật khẩu
---------------------------------
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();  // Sử dụng BCrypt để mã hóa
}

// Ví dụ mã hóa password:
String rawPassword = "123456";
String encodedPassword = passwordEncoder.encode(rawPassword);
// Kết quả: "$2a$10$N9qo8uLOickgx2ZMRZoMye..."

6. 🔄 LUỒNG HOẠT ĐỘNG HOÀN CHỈNH
===============================

Đăng ký:
--------
1. Client → POST /api/auth/signup → AuthController
2. AuthController → AuthService.registerUser()
3. AuthService → Kiểm tra email tồn tại
4. AuthService → Mã hóa password (BCrypt)
5. AuthService → Lưu User vào database
6. AuthService → Tạo UserProfile + MenstrualCycle mặc định
7. AuthService → Trả về "User registered successfully!"

Đăng nhập:
----------
1. Client → POST /api/auth/signin → AuthController
2. AuthController → AuthService.authenticateUser()
3. AuthService → AuthenticationManager.authenticate()
4. AuthenticationManager → UserDetailsServiceImpl.loadUserByUsername()
5. UserDetailsServiceImpl → UserRepository.findByEmail()
6. Spring Security → So sánh password (BCrypt)
7. AuthService → JwtUtils.generateJwtToken()
8. AuthService → Trả về AuthResponse (token + user info)

Sử dụng API với JWT:
-------------------
1. Client lưu token từ response đăng nhập
2. Client gửi request với header: "Authorization: Bearer <token>"
3. AuthTokenFilter → Lấy token từ header
4. AuthTokenFilter → JwtUtils.validateJwtToken()
5. AuthTokenFilter → Lấy email từ token
6. AuthTokenFilter → UserDetailsServiceImpl.loadUserByUsername()
7. AuthTokenFilter → Tạo Authentication object
8. AuthTokenFilter → Lưu vào SecurityContext
9. Controller → Xử lý request (user đã được xác thực)

7. 📝 VÍ DỤ SỬ DỤNG THỰC TẾ
==========================

Đăng ký user mới:
----------------
curl -X POST http://localhost:8080/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "123456",
    "fullName": "Test User"
  }'

# Response:
# {
#   "message": "User registered successfully!"
# }

Đăng nhập:
----------
curl -X POST http://localhost:8080/api/auth/signin \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "123456"
  }'

# Response:
# {
#   "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
#   "id": 1,
#   "username": "test@example.com",
#   "fullName": "Test User"
# }

Sử dụng API với JWT:
--------------------
# Lấy profile user (cần JWT token)
curl -X GET http://localhost:8080/api/users/1/profile \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Response:
# {
#   "userId": 1,
#   "fullName": "Test User",
#   "email": "test@example.com",
#   "dateOfBirth": null,
#   "avatar": null,
#   "heightCm": null,
#   "weightKg": null,
#   "gender": null
# }

8. 🚨 XỬ LÝ LỖI
===============

Lỗi đăng ký:
------------
// Email đã tồn tại
if (userRepository.existsByEmail(signUpRequest.getEmail())) {
    return new MessageResponse("Error: Email is already in use!");
}

Lỗi đăng nhập:
---------------
// Spring Security tự động throw exception nếu:
// - Email không tồn tại
// - Password sai
// - User bị khóa

Lỗi JWT:
--------
// Token hết hạn
catch (ExpiredJwtException e) {
    logger.error("JWT token is expired: {}", e.getMessage());
}

// Token không hợp lệ
catch (MalformedJwtException e) {
    logger.error("Invalid JWT token: {}", e.getMessage());
}

🎯 TÓM TẮT CHO INTERN
====================

Đăng ký:
--------
1. Kiểm tra email đã tồn tại chưa
2. Mã hóa password bằng BCrypt
3. Lưu User vào database
4. Tạo UserProfile + MenstrualCycle mặc định
5. Trả về thông báo thành công

Đăng nhập:
----------
1. Spring Security xác thực email/password
2. Tạo JWT token chứa thông tin user
3. Trả về token + thông tin user

Sử dụng API:
-----------
1. Client gửi token trong header Authorization: Bearer <token>
2. AuthTokenFilter kiểm tra token mọi request
3. Nếu token hợp lệ → Cho phép truy cập API
4. Nếu token không hợp lệ → Trả về lỗi 401

JWT Token:
----------
- Chứa thông tin user (email, thời gian tạo, hết hạn)
- Được ký bằng secret key
- Có thời hạn 24 giờ
- Không lưu trên server (stateless)

Đây là cách backend này bảo mật và xác thực người dùng một cách an toàn! 🔐✨

================================================================
Tệp được tạo bởi: AI Assistant
Ngày: 2024
Mục đích: Giải thích logic authentication và JWT cho developer intern
================================================================
